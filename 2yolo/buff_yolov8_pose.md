1.安装环境、理解模型（Netron）（1，18，8400）
（提供的模型文件为输出结果为yolov8-pose输出结果为1，18，8400，其中18为一个检测结果的特征，8400为18个特征的具体数值，
依次是检测框的x，y，w，h，
六个分类的置信度，分别为红色灯光下的中心R标、未被击打扇叶、已被击打扇叶和蓝色灯光下的中心R标、未被击打扇叶、已被击打扇叶，
后面八个数为能量机关扇叶击打区域在图像上的的左上角、右上角、右下角、左下角）
2.编写python程序，使用OpenVINO部署best.onnx模型文件，
对附件中的能量机关视频（test_video.mp4）进行检测， 
输出检测视频并标注置信度最大的分类画出相应的检测框
（首先筛选出置信度大于0.5的检测框，然后对置信度最大的检测框进行NMS非极大值抑制处理，将非极大值抑制后的检测框的索引保存在列表中，最后将检测框画在视频上并保存）。
3.根据下文给定参考点和相机内参，（上文将非极大值抑制的索引保存，通过索引取出对应在18个数中的后八个数，即为能量机关扇叶击打区域的左上角、右上角、右下角、左下角。
）由能量机关扇叶击打区域的左上角、右上角、右下角、左下角计算其在相机坐标系下的位置，
使用PnP输出其相对于相机坐标系的位置与姿态信息（旋转向量和平移向量）

4.调试过程
detect为onnxruntime的参考代码，
yolov8――pose_ov_sync_infer.py为OpenVINO部署onnx模型的参考代码，
buff_yolov8_pose.py参考onnxruntime的python接口，使用OpenVINO部署onnx模型文件，能力太菜，很多地方出问题了。
buff_yolov8_pose2.py是实现了的




给定相机内参如下：

```
图像宽度
image_width: 1280
图像高度
image_height: 1024
相机名称
camera_name: narrow_stereo
相机矩阵包括内参
camera_matrix:
  rows: 3
  cols: 3
  data: [2075.15666,    0.     ,  646.02307,
            0.     , 2073.92438,  479.8963 ,
            0.     ,    0.     ,    1.     ]
畸变模型
distortion_model: plumb_bob
畸变系数
distortion_coefficients:
  rows: 1
  cols: 5
  data: [-0.051148, 0.231678, 0.000775, 0.002697, 0.000000]
矫正矩阵
rectification_matrix:
  rows: 3
  cols: 3
  data: [1., 0., 0.,
         0., 1., 0.,
         0., 0., 1.]
投影矩阵
projection_matrix:
  rows: 3
  cols: 4
  data: [2069.80322,    0.     ,  647.4636 ,    0.     ,
            0.     , 2070.58691,  479.94672,    0.     ,
            0.     ,    0.     ,    1.     ,    0.     ]
```

给定能量机关参考点如下：（而给定的参考点为五个特征点，上述参考点依次为能量机关扇叶击打区域的左上角、右上角、右下角、中心R标和扇叶击打区域左下角。）

```
buff_3d_points = {
  {0, 0.1700, 0.1750}, 
  {0, -0.1700, 0.1750},
  {0, -0.1850, -0.1650},
  {0, 0, -0.7150},
  {0, 0.1850, -0.1650}};
buff_2d_points = {
  {0, 0.1700, 0.1750}, 
  {0, -0.1700, 0.1750},
  {0, -0.1850, -0.1650},
  {0, 0.1850, -0.1650}};
```

模型输出
